{"id":956166596,"lang":"python3","lang_name":"Python3","time":"3 weeks, 5 days","timestamp":1684896267,"status":10,"status_display":"Accepted","runtime":"66 ms","url":"/submissions/detail/956166596/","is_pending":"Not Pending","title":"Binary Tree Level Order Traversal","memory":"17.1 MB","code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        #generate queue and append root to queue\n        #while there are nodes in the queue, \n            #iterate through the number of nodes in the queue \n                #(this is the number of nodes in the next level)\n            #pop queue(0), add queue(0).val to current ans list and append                       queue(0)'s children to queue\n            #append ans to final_list and reset ans = []\n        \n        if root is None:\n            return root\n        queue = []\n        return_list = []\n        queue.append(root)\n        while len(queue) > 0:\n            ans = []\n            l = len(queue)\n            for l in range(l):\n                node = queue.pop(0)\n                ans.append(node.val)\n                if node.left != None:\n                    queue.append(node.left)\n                if node.right != None:\n                    queue.append(node.right)\n            return_list.append(ans)\n        return return_list","compare_result":"11111111111111111111111111111111111","title_slug":"binary-tree-level-order-traversal","has_notes":false}